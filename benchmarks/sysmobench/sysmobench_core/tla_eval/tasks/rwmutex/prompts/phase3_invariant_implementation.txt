You are a TLA+ expert specializing in concurrent systems and synchronization primitives. Your task is to implement a set of expert-written invariants for the given read-write mutex TLA+ specification.

## Target Specification

$tla_specification

## Invariants to Implement

$invariant_templates

## Implementation Requirements

1. **Deep Analysis**: First, thoroughly understand both the invariant template's semantic intent and the specification's modeling approach:
   - What safety/liveness property does each template aim to verify?
   - How does the specification represent states, operations, and concurrency?
   - What are the semantic equivalents between template concepts and specification implementation?

2. **Semantic Mapping**: For each invariant, identify the conceptual mapping between template and specification:
   - Template `"reading"` state → Specification's reader states (e.g., `"read_locked"`, reader count > 0)
   - Template `"writing"` state → Specification's writer states (e.g., `"write_locked"`, writer bit set)
   - Template `"upgrading"` state → Specification's upgradeable reader states and upgrade transitions
   - Template reader/writer counts → Specification's reader counting and exclusive writer tracking
   - Template thread sets → Specification's thread/process constants

3. **Creative Adaptation**: Translate the invariant while preserving its core semantic meaning:
   - **DO NOT** simply replace variable names - understand the underlying logic
   - **DO** redesign the predicate logic to fit the specification's modeling granularity
   - **DO** use equivalent semantic concepts even if names/structures differ
   - **PRESERVE** the original safety/liveness intent without weakening the property

4. **TLA+ Property Type Constraints**:
   
   **FOR SAFETY PROPERTIES** (type: "safety"):
   - **MUST** be STATE PREDICATES (describe single states only)
   - **NEVER** use primed variables (`pc'`, `lock_state'`)
   - **NEVER** use temporal operators (`[]`, `<>`, `~>`)
   - **NEVER** reference actions (like `ReadLock(p)`, `WriteLock(p)`, `Upgrade(p)`) - only use state variables
   - **ONLY** use unprimed variables (`pc[t]`, `lock_state`) and constants
   - **CORRECT**: `ReaderWriterExclusion == ~((\E r \in Readers : pc[r] = "reading") /\ (\E w \in Writers : pc[w] = "writing"))` 
   - **INCORRECT**: `pc[t] = "requesting" => pc'[t] = "granted"`  (has primed variable)
   - **INCORRECT**: `pc[p] = "upgrading" => Upgrade(p)`  (references action Upgrade)

   **FOR LIVENESS PROPERTIES** (type: "liveness"): 
   - **MUST** be TEMPORAL FORMULAS (describe execution traces)
   - **MUST** use temporal operators (`<>`, `~>`) to express "eventually" or "leads-to"
   - **MAY** use both primed and unprimed variables as needed
   - **CORRECT**: `EventualAccess == ∀t ∈ Threads : (pc[t] = "waiting") ~> (pc[t] \in {"reading", "writing"})` 
   - **INCORRECT**: `EventualAccess == pc[t] = "waiting"`  (missing temporal aspect)

5. **Constraint Compliance**:
   - Use ONLY variables, constants, and operators that exist in the specification
   - Generate complete, syntactically valid TLA+ invariant definitions
   - Maintain the exact invariant names from templates

6. **Output format**: Return a JSON object containing an array of complete TLA+ invariant definitions

7. **EXACT naming requirement**: You MUST use the exact invariant names specified in the templates above. Do not create your own names.

## Example Output Format

```json
{
  "invariants": [
    "ReaderWriterExclusion == ~((\\E r \\in Readers : pc[r] = \"reading\") /\\ (\\E w \\in Writers : pc[w] = \"writing\"))",
    "MultipleReadersAllowed == Cardinality({t \\in Threads : pc[t] = \"reading\"}) >= 0",
    "EventualWriterAccess == \\A w \\in Writers : (pc[w] = \"waiting_write\") ~> (pc[w] = \"writing\")"
  ]
}
```

**CRITICAL REQUIREMENTS**: 
- **PROPERTY TYPE AWARENESS**: Check each invariant's type field - safety properties MUST be state predicates, liveness properties MUST be temporal formulas
- **SAFETY PROPERTIES**: Use ONLY unprimed variables, NO temporal operators (`[]`, `<>`, `~>`)
- **LIVENESS PROPERTIES**: MUST use temporal operators (`<>`, `~>`) to express "eventually" or "leads-to" relationships
- **SEMANTIC PRESERVATION**: Each translated invariant MUST verify the same safety/liveness property as the original template
- **CREATIVE ADAPTATION**: Do NOT simply omit invariants - find creative ways to express the same property using available specification elements
- **COMPLETENESS**: Aim to translate ALL invariants by understanding their semantic intent, not just their syntactic form
- Use ONLY variables, constants, and operators that exist in the provided specification
- Use EXACTLY the invariant names from the templates (ReaderWriterExclusion, MultipleReadersAllowed, WriterExclusivity, UpgradeableReaderUniqueness, NoReaderWriterConflict, EventualWriterAccess, EventualReaderAccess)
- Return ONLY valid JSON, no explanatory text before or after
- Each array element must be a complete TLA+ invariant definition: "InvariantName == <expression>"
- For complex invariants, you may use multiline format within the JSON string (use actual line breaks)
- For simple invariants, single line format is preferred
- **LAST RESORT**: Only omit an invariant if its core concept is fundamentally incompatible with the specification's design
- **CRITICAL JSON ESCAPING RULES**: 
  - TLA+ operators like `\A`, `\E`, `\in` contain ONE backslash in the final TLA+ code
  - In JSON strings, use EXACTLY ONE backslash escape: write `"\\A"` to get `\A` in TLA+
  - **DO NOT double-escape**: `"\\\\A"` is WRONG and will produce `\\A` in TLA+
  - **CORRECT**: `"ReaderWriterExclusion == \\A t \\in Threads : pc[t] = \"reading\" => ~(\\E w \\in Writers : pc[w] = \"writing\")"`
  - **WRONG**: `"ReaderWriterExclusion == \\\\A t \\\\in Threads : pc[t] = \"reading\" => ~(\\\\E w \\\\in Writers : pc[w] = \"writing\")"`
- Start your response immediately with the opening brace {